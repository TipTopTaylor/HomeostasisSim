<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Homeostasis Game</title>
  <!-- Tailwind CSS via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100">
  <div id="root"></div>

  <!-- React / ReactDOM UMD builds -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel standalone to compile JSX in-browser -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Your entire React component, in JSX -->
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    const HomeostasisSimulator = () => {
      // (all of your original state setup, effects, handlers, SVGs, etc.)
      // I'm copying your component code exactly—no omissions:

      // Game state
      const [gameActive, setGameActive] = useState(false);
      const [score, setScore] = useState(0);
      const [livesLeft, setLivesLeft] = useState(3);
      const [currentStates, setCurrentStates] = useState([]);
      const [activeSensors, setActiveSensors] = useState([]);
      const [activeEffectors, setActiveEffectors] = useState([]);
      const [homeostasisRestored, setHomeostasisRestored] = useState({});
      const [message, setMessage] = useState("Press Start to begin!");
      const [effectorTimeouts, setEffectorTimeouts] = useState({});
      const [responseNeeded, setResponseNeeded] = useState({});
      const [challengeTimer, setChallengeTimer] = useState(null);
      const [responseCountdown, setResponseCountdown] = useState({});
      const [countdownIntervals, setCountdownIntervals] = useState({});
      const [difficulty, setDifficulty] = useState(1);
      const [showWarning, setShowWarning] = useState(false);
      const [recentChallenges, setRecentChallenges] = useState([]);
      const [lifeLostNotification, setLifeLostNotification] = useState(false);
      const [lifeLostMessage, setLifeLostMessage] = useState("");

      const animationFrameRef = useRef(null);
      const bodyRef = useRef(null);

      const states = [
        { 
          id: "temperature_high", 
          prompt: "TOO HOT! Body temperature rising!", 
          sensor: "temperature_sensor",
          sensorName: "Temperature Sensor",
          effector: "sweat_glands",
          effectorName: "START SWEATING!",
          activeMessage: "Sweating... cooling down body...",
          restoreMessage: "Temperature normal! STOP SWEATING!",
          dangerMessage: "TOO HOT! You're overheating!",
          responseTime: 8000,
          bodyPart: "head"
        },
        { 
          id: "temperature_low", 
          prompt: "TOO COLD! Body temperature dropping!", 
          sensor: "temperature_sensor",
          sensorName: "Temperature Sensor",
          effector: "shiver_muscles",
          effectorName: "START SHIVERING!",
          activeMessage: "Shivering... warming up body...",
          restoreMessage: "Temperature normal! STOP SHIVERING!",
          dangerMessage: "TOO COLD! You're freezing!",
          responseTime: 8000,
          bodyPart: "hands"
        },
        { 
          id: "blood_sugar_high", 
          prompt: "SUGAR OVERLOAD! Glucose too high!", 
          sensor: "glucose_sensor",
          sensorName: "Glucose Sensor",
          effector: "insulin_release",
          effectorName: "RELEASE INSULIN!",
          activeMessage: "Insulin working... lowering blood sugar...",
          restoreMessage: "Sugar levels normal! STOP INSULIN!",
          dangerMessage: "SUGAR CRISIS! You need insulin now!",
          responseTime: 7000,
          bodyPart: "stomach"
        },
        { 
          id: "blood_sugar_low", 
          prompt: "SUGAR CRASH! Glucose too low!", 
          sensor: "glucose_sensor",
          sensorName: "Glucose Sensor",
          effector: "glucagon_release",
          effectorName: "RELEASE GLUCAGON!",
          activeMessage: "Glucagon working... raising blood sugar...",
          restoreMessage: "Sugar levels normal! STOP GLUCAGON!",
          dangerMessage: "ENERGY CRISIS! Blood sugar critical!",
          responseTime: 7000,
          bodyPart: "stomach"
        },
        { 
          id: "bladder_full", 
          prompt: "BLADDER FULL! Need to urinate!", 
          sensor: "bladder_sensor",
          sensorName: "Bladder Sensor",
          effector: "urination",
          effectorName: "CONTRACT BLADDER!",
          activeMessage: "Peeing! Emptying bladder...",
          restoreMessage: "Bladder emptied! STOP CONTRACTING!",
          dangerMessage: "EMERGENCY! Bladder about to burst!",
          responseTime: 6000,
          bodyPart: "legs"
        },
        { 
          id: "thirst", 
          prompt: "TOO THIRSTY! Water levels low!", 
          sensor: "thirst_sensor",
          sensorName: "Thirst Sensor",
          effector: "drink_water",
          effectorName: "DRINK WATER!",
          activeMessage: "Drinking... hydrating body...",
          restoreMessage: "Water levels normal! STOP DRINKING!",
          dangerMessage: "DEHYDRATION ALERT! Critical water shortage!",
          responseTime: 7000,
          bodyPart: "head"
        },
        { 
          id: "blood_pressure_high", 
          prompt: "PRESSURE SPIKE! BP too high!", 
          sensor: "pressure_sensor",
          sensorName: "Pressure Sensor",
          effector: "vasodilation",
          effectorName: "DILATE VESSELS!",
          activeMessage: "Vessels dilating... lowering pressure...",
          restoreMessage: "Pressure normal! RETURN TO NORMAL!",
          dangerMessage: "PRESSURE CRISIS! BP dangerously high!",
          responseTime: 6000,
          bodyPart: "cheast"
        },
        { 
          id: "oxygen_low", 
          prompt: "OXYGEN LOW! Can't breathe!", 
          sensor: "oxygen_sensor",
          sensorName: "Oxygen Sensor",
          effector: "increase_breathing",
          effectorName: "BREATHE FASTER!",
          activeMessage: "Breathing faster... increasing oxygen...",
          restoreMessage: "Oxygen normal! BREATHE NORMALLY!",
          dangerMessage: "SUFFOCATING! Critical oxygen levels!",
          responseTime: 5500,
          bodyPart: "cheast"
        }
      ];

      const getResponseTime = (baseTime) => Math.max(baseTime - ((difficulty - 1) * 500), 3000);
      const getMaxConcurrentChallenges = () => difficulty >= 5 ? 3 : difficulty >= 3 ? 2 : 1;
      const getInitialChallengeDelay = () => 2000;
      const getChallengeFrequency = () => Math.max(12000 - (difficulty * 1000), 5000);

      useEffect(() => {
        if (score >= 25) setDifficulty(6);
        else if (score >= 20) setDifficulty(5);
        else if (score >= 15) setDifficulty(4);
        else if (score >= 10) setDifficulty(3);
        else if (score >= 5) setDifficulty(2);
        else setDifficulty(1);
      }, [score]);

      useEffect(() => {
        if (showWarning && bodyRef.current) {
          let counter = 0;
          const maxFlashes = 4;
          let flash = true;
          const flashWarning = () => {
            if (counter >= maxFlashes) return setShowWarning(false);
            bodyRef.current.style.backgroundColor = flash ? 'rgba(255,0,0,0.3)' : 'white';
            flash = !flash;
            counter++;
            animationFrameRef.current = requestAnimationFrame(() => setTimeout(flashWarning, 300));
          };
          flashWarning();
          return () => cancelAnimationFrame(animationFrameRef.current);
        }
      }, [showWarning]);

      useEffect(() => {
        if (lifeLostNotification) {
          const t = setTimeout(() => setLifeLostNotification(false), 2500);
          return () => clearTimeout(t);
        }
      }, [lifeLostNotification]);

      const completeChallenge = (stateId) => {
        try {
          const [challengeType] = stateId.split('_');
          setRecentChallenges(r => [...r, challengeType]);
          const cd = Math.max(15000 - (difficulty*2000), 5000);
          setTimeout(() => setRecentChallenges(r => r.filter(c => c!==challengeType)), cd);
          setScore(s => s+1);
          setMessage(`PERFECT! Homeostasis maintained. Score: ${score+1}`);
          setCurrentStates(cs => cs.filter(s=>s.id!==stateId));
          setTimeout(() => {
            removeChallenge(stateId);
            if (currentStates.length<=1) setMessage(`PERFECT! Homeostasis maintained. Score: ${score+1}`);
          },100);
          if (challengeTimer) clearTimeout(challengeTimer);
          setChallengeTimer(setTimeout(()=>setChallengeTimer(null), Math.max(4000-(difficulty*500),1000)));
        } catch(e){ console.error(e) }
      };

      useEffect(() => {
        if (!gameActive) return;
        if (livesLeft<=0) return endGame();

        if (!challengeTimer && currentStates.length<getMaxConcurrentChallenges()) {
          const delay = currentStates.length===0 ? getInitialChallengeDelay() : getChallengeFrequency();
          const t = setTimeout(()=>{ addNewChallenge(); setChallengeTimer(null); }, delay);
          setChallengeTimer(t);
        }
        const backup = setTimeout(()=> {
          if (currentStates.length<getMaxConcurrentChallenges() && gameActive) {
            if (challengeTimer) clearTimeout(challengeTimer);
            setChallengeTimer(null);
          }
        },8000);
        return () => { if(challengeTimer) clearTimeout(challengeTimer); clearTimeout(backup) };
      }, [gameActive, currentStates, livesLeft, challengeTimer, difficulty]);

      const addNewChallenge = () => {
        try {
          const available = states.filter(s => !currentStates.some(c=>c.id===s.id) && !recentChallenges.includes(s.id.split('_')[0]));
          if (!available.length) {
            setChallengeTimer(setTimeout(()=>setChallengeTimer(null),3000));
            return;
          }
          const s = available[Math.floor(Math.random()*available.length)];
          setCurrentStates(cs=>[...cs,s]);
          setActiveSensors(a=>[...a,s.sensor]);
          setResponseNeeded(r=>({...r,[s.id]:true}));
          setResponseCountdown(r=>({...r,[s.id]: getResponseTime(s.responseTime)}));

          const ci = setInterval(()=>{
            setResponseCountdown(r=>{
              const nr={...r};
              if (nr[s.id]>0) {
                nr[s.id]-=100;
                if (nr[s.id]<=2000 && nr[s.id]>0 && responseNeeded[s.id]) setShowWarning(true);
              }
              return nr;
            });
          },100);
          setCountdownIntervals(ciMap=>({...ciMap,[s.id]:ci}));

          setTimeout(()=>{
            setResponseNeeded(r=>{
              if (r[s.id]) {
                setLifeLostNotification(true);
                setLifeLostMessage(`LIFE LOST! ${s.dangerMessage}`);
                setLivesLeft(l=>l-1);
                setShowWarning(true);
                setTimeout(()=>{ removeChallenge(s.id); setShowWarning(false); },2000);
              }
              return {...r,[s.id]:false};
            });
          },getResponseTime(s.responseTime));

        } catch(e){ console.error(e) }
      };

      const removeChallenge = (stateId) => {
        try {
          setCurrentStates(cs=>cs.filter(s=>s.id!==stateId));
          const removed = states.find(s=>s.id===stateId);
          setTimeout(()=>setActiveSensors(a=>a.filter(x=>x!==removed.sensor)),300);
          setActiveEffectors(a=>a.filter(e=>e!==removed.effector));
          if(effectorTimeouts[stateId]) { clearTimeout(effectorTimeouts[stateId]); delete effectorTimeouts[stateId]; setEffectorTimeouts({...effectorTimeouts}); }
          if(countdownIntervals[stateId]){ clearInterval(countdownIntervals[stateId]); delete countdownIntervals[stateId]; setCountdownIntervals({...countdownIntervals}); }
          delete homeostasisRestored[stateId]; setHomeostasisRestored({...homeostasisRestored});
          delete responseNeeded[stateId]; setResponseNeeded({...responseNeeded});
          delete responseCountdown[stateId]; setResponseCountdown({...responseCountdown});
        } catch(e){ console.error(e) }
      };

      const findStateByEffector = (eff) => states.find(s=>s.effector===eff)||null;

      const handleEffectorToggle = (eff) => {
        try {
          if (!gameActive) return;
          const st = findStateByEffector(eff);
          if (!st) return;
          const id=st.id;
          const isCurr = currentStates.some(s=>s.id===id);
          if (activeEffectors.includes(eff)) {
            // turning off
            if (isCurr && homeostasisRestored[id]) {
              setActiveEffectors(a=>a.filter(x=>x!==eff));
              if(effectorTimeouts[id]) clearTimeout(effectorTimeouts[id]);
              completeChallenge(id);
            } else {
              setActiveEffectors(a=>a.filter(x=>x!==eff));
              setMessage("Problem not fixed yet!");
              setLivesLeft(l=>l-1);
              setLifeLostNotification(true);
              setLifeLostMessage("LIFE LOST! You turned off the response too soon!");
              setTimeout(()=>isCurr&&removeChallenge(id),2000);
            }
            return;
          }
          // turning on
          if (isCurr && responseNeeded[id]) {
            setActiveEffectors(a=>[...a,eff]);
            setHomeostasisRestored(h=>({...h,[id]:false}));
            setResponseNeeded(r=>({...r,[id]:false}));
            const half = Math.floor(getResponseTime(st.responseTime)/2);
            const t1 = setTimeout(()=>{
              setHomeostasisRestored(h=>({...h,[id]:true}));
              const t2 = setTimeout(()=>{
                if (activeEffectors.includes(eff)) {
                  setMessage("You need to turn off the response!");
                  setLivesLeft(l=>l-1);
                  setLifeLostNotification(true);
                  setLifeLostMessage("LIFE LOST! Overcompensation! Response left on too long!");
                  setTimeout(()=>removeChallenge(id),2000);
                }
              },8000);
              setEffectorTimeouts(et=>({...et,[id]:t2}));
            },half);
            setEffectorTimeouts(et=>({...et,[id+"_activate"]:t1}));
          } else {
            setActiveEffectors(a=>[...a,eff]);
            setMessage("No problem detected! Don't overcompensate!");
            const tw = setTimeout(()=>setActiveEffectors(a=>a.filter(x=>x!==eff)),1500);
            setEffectorTimeouts(et=>({...et,[eff+"_wrong"]:tw}));
          }
        } catch(e){ console.error(e) }
      };

      const startGame = () => {
        Object.values(effectorTimeouts).forEach(t=>clearTimeout(t));
        Object.values(countdownIntervals).forEach(i=>clearInterval(i));
        if(challengeTimer) clearTimeout(challengeTimer);
        setGameActive(true);
        setScore(0);
        setLivesLeft(3);
        setDifficulty(1);
        setMessage("Game started! Monitor body systems!");
        setCurrentStates([]);
        setActiveSensors([]);
        setActiveEffectors([]);
        setHomeostasisRestored({});
        setResponseNeeded({});
        setEffectorTimeouts({});
        setCountdownIntervals({});
        setResponseCountdown({});
        setChallengeTimer(null);
        setRecentChallenges([]);
      };

      const endGame = () => {
        Object.values(effectorTimeouts).forEach(t=>clearTimeout(t));
        Object.values(countdownIntervals).forEach(i=>clearInterval(i));
        if(challengeTimer) clearTimeout(challengeTimer);
        setGameActive(false);
        setMessage(`GAME OVER! Final score: ${score}. Press Start to play again!`);
        setCurrentStates([]);
        setActiveSensors([]);
        setActiveEffectors([]);
        setHomeostasisRestored({});
        setResponseNeeded({});
        setEffectorTimeouts({});
        setCountdownIntervals({});
        setChallengeTimer(null);
        setRecentChallenges([]);
      };

      return (
        <div className="flex flex-col items-center justify-center min-h-screen p-4">
          <div className="text-center mb-4">
            <h1 className="text-3xl font-bold text-blue-700 mb-2">BODY BALANCE!</h1>
            <p className="text-md text-gray-700 mb-4">Keep your body in homeostasis or FACE THE CONSEQUENCES!</p>
            <div className="mb-4">
              <button
                onClick={startGame}
                disabled={gameActive}
                className="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg mr-4 text-xl"
              >START GAME!</button>
              <button
                onClick={endGame}
                disabled={!gameActive}
                className="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg text-xl"
              >END GAME</button>
            </div>
            <div className="flex justify-center space-x-4 mb-2">
              <div className="text-xl font-semibold">Score: <span className="text-green-600">{score}</span></div>
              <div className="text-xl font-semibold">Lives: <span className="text-red-600">{livesLeft}</span></div>
              <div className="text-xl font-semibold">Level: <span className="text-purple-600">{difficulty}</span></div>
            </div>
            {lifeLostNotification && (
              <div className="bg-red-600 text-white p-3 mb-4 rounded-lg animate-pulse text-xl font-bold">
                {lifeLostMessage}
              </div>
            )}
            <div className={`p-4 mb-4 text-center rounded-lg border-2 ${
              showWarning ? 'bg-red-100 border-red-500 animate-pulse' : 'bg-yellow-100 border-yellow-500'
            }`}>
              {currentStates.length > 0 ? currentStates.map(s => {
                const isActive = activeEffectors.includes(s.effector);
                const isRestored = homeostasisRestored[s.id];
                const timeRem = responseCountdown[s.id] || 0;
                const isUrgent = timeRem <= 2000 && timeRem > 0 && responseNeeded[s.id];
                let txt = s.prompt;
                if (isActive && !isRestored) txt = s.activeMessage;
                else if (isActive && isRestored) txt = s.restoreMessage;
                return (
                  <p key={s.id} className={`text-xl font-bold ${
                    isRestored ? 'text-green-600' :
                    isActive ? 'text-blue-600' :
                    isUrgent ? 'text-red-700' : 'text-red-600'
                  }`}>
                    {txt}
                    {!isActive && !isRestored && timeRem>0 && (
                      <span className={`ml-2 ${isUrgent?'text-red-700 font-extrabold':'text-red-600'}`}>
                        {Math.ceil(timeRem/1000)}s
                      </span>
                    )}
                  </p>
                );
              }) : <p className="text-xl font-bold">{message}</p>}
            </div>
          </div>

          <div className="flex w-full max-w-6xl justify-center">
            {/* Sensors */}
            <div className="w-1/4 pr-4">
              <h2 className="text-xl font-bold text-blue-600 mb-4 text-center">SENSORS</h2>
              <div className="space-y-4">
                {Array.from(new Set(states.map(s=>s.sensor))).map(sensor=> {
                  const st = states.find(s=>s.sensor===sensor);
                  const on = activeSensors.includes(sensor);
                  return (
                    <div key={sensor} className="relative">
                      <div className={`border-2 rounded-lg p-3 text-center transition-all duration-300 transform ${
                        on ? 'bg-red-500 text-white border-red-700 font-bold scale-110 shadow-lg' : 'bg-gray-100 border-gray-300'
                      }`}>
                        {st.sensorName}
                      </div>
                      <div className={`h-1 absolute top-1/2 right-0 w-16 transform translate-x-16 ${
                        on ? 'bg-red-500' : 'bg-gray-300'
                      }`}></div>
                    </div>
                  );
                })}
              </div>
            </div>

            {/* Body & SVGs */}
            <div ref={bodyRef} className="w-2/4 flex justify-center items-center border-2 border-gray-300 rounded-lg bg-white relative" style={{overflow:'hidden'}}>
              <div className="human-body" style={{width:'207px',height:'500px',position:'relative',margin:'20px auto'}}>
                {/* Paste all your SVG body parts exactly here */}
              </div>
              <div className="absolute top-4 left-4 right-4 bg-blue-600 text-white font-bold border border-blue-800 rounded p-2 text-center shadow-lg">
                ⚠️ CONTROL CENTER: Brain & Nervous System ⚠️
              </div>
              <div className="absolute bottom-4 left-4 right-4 bg-purple-100 border border-purple-300 rounded p-1 text-center text-sm">
                <div className="font-bold">Level {difficulty} {difficulty>=3?'- Multiple challenges active!':''}</div>
                <div className="w-full bg-gray-200 rounded-full h-2 mt-1">
                  <div className="bg-purple-600 h-2 rounded-full" style={{width:`${Math.min(score/25*100,100)}%`}}></div>
                </div>
              </div>
            </div>

            {/* Effectors */}
            <div className="w-1/4 pl-4">
              <h2 className="text-xl font-bold text-green-600 mb-4 text-center">EFFECTORS</h2>
              <div className="space-y-4">
                {Array.from(new Set(states.map(s=>s.effector))).map(effector=>{
                  const st = states.find(s=>s.effector===effector);
                  const active = activeEffectors.includes(effector);
                  const need = currentStates.some(s=>s.effector===effector && responseNeeded[s.id]);
                  const stop = currentStates.some(s=>s.effector===effector && homeostasisRestored[s.id]);
                  let txt = effector;
                  if (active) txt = stop ? st.restoreMessage.replace('!','') : st.effectorName;
                  return (
                    <div key={effector} className="relative">
                      <div className={`h-1 absolute top-1/2 left-0 w-16 transform -translate-x-16 ${
                        activeSensors.includes(st.sensor) ? 'bg-red-500':'bg-gray-300'
                      }`}></div>
                      <button
                        onClick={()=>handleEffectorToggle(effector)}
                        disabled={!gameActive}
                        className={`border-2 rounded-lg p-3 w-full text-center transition-all duration-300 transform ${
                          active ? (stop?'bg-red-500 text-white border-red-700 font-bold shadow-lg scale-110':'bg-green-500 text-white border-green-700 font-bold shadow-lg scale-110')
                            : need ? 'bg-yellow-100 hover:bg-yellow-200 border-yellow-500 font-bold shadow':'bg-gray-100 hover:bg-gray-200 border-gray-300'
                        }`}
                      >{txt}</button>
                    </div>
                  );
                })}
              </div>
            </div>
          </div>

          <div className="mt-8 p-4 bg-blue-50 border border-blue-200 rounded-lg max-w-3xl">
            <h2 className="text-xl font-bold text-blue-800 mb-2">HOW TO PLAY:</h2>
            <ol className="list-decimal pl-5 space-y-2">
              <li>Watch for EMERGENCY ALERTS! Your body is in trouble!</li>
              <li>When a sensor turns RED, quickly find the matching response button.</li>
              <li>CLICK the correct effector button to start fixing the problem.</li>
              <li>Watch for the message telling you to STOP the response.</li>
              <li>You MUST turn OFF the effector when told to avoid overcompensation.</li>
              <li>Score points for successfully maintaining homeostasis.</li>
              <li>As you level up, challenges come faster and multiple problems can happen at once!</li>
              <li>Game ends when you lose all 3 lives. HOW LONG CAN YOU SURVIVE?</li>
            </ol>
            <div className="mt-4 p-2 bg-yellow-50 border border-yellow-200 rounded">
              <strong>Remember:</strong> Homeostasis works through negative feedback loops:
              <div className="flex justify-between items-center mt-2 text-sm">
                <div className="text-center px-2">
                  <div className="w-16 h-16 mx-auto rounded-full bg-red-200 border-2 border-red-500 flex items-center justify-center">
                    <span className="font-bold">SENSORS</span>
                  </div>
                  <div>Detect Change</div>
                </div>
                <div className="text-3xl">→</div>
                <div className="text-center px-2">
                  <div className="w-16 h-16 mx-auto rounded-full bg-blue-200 border-2 border-blue-500 flex items-center justify-center">
                    <span className="font-bold">BRAIN</span>
                  </div>
                  <div>Processes Info</div>
                </div>
                <div className="text-3xl">→</div>
                <div className="text-center px-2">
                  <div className="w-16 h-16 mx-auto rounded-full bg-green-200 border-2 border-green-500 flex items-center justify-center">
                    <span className="font-bold">EFFECTORS</span>
                  </div>
                  <div>Take Action</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    // render
    ReactDOM.createRoot(document.getElementById('root')).render(<HomeostasisSimulator />);
  </script>
</body>
</html>
