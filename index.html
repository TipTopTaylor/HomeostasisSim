<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Homeostasis Game</title>
  <!-- Tailwind CSS via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100">
  <div id="root"></div>

  <!-- React / ReactDOM UMD builds -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel standalone to compile JSX in-browser -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const HomeostasisSimulator = () => {
      // Game state
      const [gameActive, setGameActive] = useState(false);
      const [score, setScore] = useState(0);
      const [livesLeft, setLivesLeft] = useState(3);
      const [currentStates, setCurrentStates] = useState([]);
      const [activeSensors, setActiveSensors] = useState([]);
      const [activeEffectors, setActiveEffectors] = useState([]);
      const [homeostasisRestored, setHomeostasisRestored] = useState({});
      const [message, setMessage] = useState("Press Start to begin!");
      const [effectorTimeouts, setEffectorTimeouts] = useState({});
      const [responseNeeded, setResponseNeeded] = useState({});
      const [challengeTimer, setChallengeTimer] = useState(null);
      const [responseCountdown, setResponseCountdown] = useState({});
      const [countdownIntervals, setCountdownIntervals] = useState({});
      const [difficulty, setDifficulty] = useState(1);
      const [showWarning, setShowWarning] = useState(false);
      const [recentChallenges, setRecentChallenges] = useState([]);
      const [lifeLostNotification, setLifeLostNotification] = useState(false);
      const [lifeLostMessage, setLifeLostMessage] = useState("");
      const [showMemoryModePopup, setShowMemoryModePopup] = useState(false);
      const [memoryModePopupShown, setMemoryModePopupShown] = useState(false);

      const animationFrameRef = useRef(null);
      const bodyRef = useRef(null);

      // Full state definitions
      const states = [
        { 
          id: "temperature_high", 
          prompt: "TOO HOT! Body temperature rising!", 
          sensor: "temperature_sensor",
          sensorName: "Temperature Sensor",
          effector: "sweat_glands",
          effectorName: "START SWEATING!",
          activeMessage: "Sweating... cooling down body...",
          restoreMessage: "Temperature normal! STOP SWEATING!",
          dangerMessage: "TOO HOT! You're overheating!",
          responseTime: 8000,
          bodyPart: "head"
        },
        { 
          id: "temperature_low", 
          prompt: "TOO COLD! Body temperature dropping!", 
          sensor: "temperature_sensor",
          sensorName: "Temperature Sensor",
          effector: "shiver_muscles",
          effectorName: "START SHIVERING!",
          activeMessage: "Shivering... warming up body...",
          restoreMessage: "Temperature normal! STOP SHIVERING!",
          dangerMessage: "TOO COLD! You're freezing!",
          responseTime: 8000,
          bodyPart: "hands"
        },
        { 
          id: "blood_sugar_high", 
          prompt: "SUGAR OVERLOAD! Glucose too high!", 
          sensor: "glucose_sensor",
          sensorName: "Glucose Sensor",
          effector: "insulin_release",
          effectorName: "RELEASE INSULIN!",
          activeMessage: "Insulin working... lowering blood sugar...",
          restoreMessage: "Sugar levels normal! STOP INSULIN!",
          dangerMessage: "SUGAR CRISIS! You need insulin now!",
          responseTime: 7000,
          bodyPart: "stomach"
        },
        { 
          id: "blood_sugar_low", 
          prompt: "SUGAR CRASH! Glucose too low!", 
          sensor: "glucose_sensor",
          sensorName: "Glucose Sensor",
          effector: "glucagon_release",
          effectorName: "RELEASE GLUCAGON!",
          activeMessage: "Glucagon working... raising blood sugar...",
          restoreMessage: "Sugar levels normal! STOP GLUCAGON!",
          dangerMessage: "ENERGY CRISIS! Blood sugar critical!",
          responseTime: 7000,
          bodyPart: "stomach"
        },
        { 
          id: "bladder_full", 
          prompt: "BLADDER FULL! Need to urinate!", 
          sensor: "bladder_sensor",
          sensorName: "Bladder Sensor",
          effector: "urination",
          effectorName: "CONTRACT BLADDER!",
          activeMessage: "Peeing! Emptying bladder...",
          restoreMessage: "Bladder emptied! STOP CONTRACTING!",
          dangerMessage: "EMERGENCY! Bladder about to burst!",
          responseTime: 6000,
          bodyPart: "legs"
        },
        { 
          id: "thirst", 
          prompt: "TOO THIRSTY! Water levels low!", 
          sensor: "thirst_sensor",
          sensorName: "Thirst Sensor",
          effector: "drink_water",
          effectorName: "DRINK WATER!",
          activeMessage: "Drinking... hydrating body...",
          restoreMessage: "Water levels normal! STOP DRINKING!",
          dangerMessage: "DEHYDRATION ALERT! Critical water shortage!",
          responseTime: 7000,
          bodyPart: "head"
        },
        { 
          id: "blood_pressure_high", 
          prompt: "PRESSURE SPIKE! BP too high!", 
          sensor: "pressure_sensor",
          sensorName: "Pressure Sensor",
          effector: "vasodilation",
          effectorName: "DILATE VESSELS!",
          activeMessage: "Vessels dilating... lowering pressure...",
          restoreMessage: "Pressure normal! RETURN TO NORMAL!",
          dangerMessage: "PRESSURE CRISIS! BP dangerously high!",
          responseTime: 6000,
          bodyPart: "cheast"
        },
        { 
          id: "oxygen_low", 
          prompt: "OXYGEN LOW! Can't breathe!", 
          sensor: "oxygen_sensor",
          sensorName: "Oxygen Sensor",
          effector: "increase_breathing",
          effectorName: "BREATHE FASTER!",
          activeMessage: "Breathing faster... increasing oxygen...",
          restoreMessage: "Oxygen normal! BREATHE NORMALLY!",
          dangerMessage: "SUFFOCATING! Critical oxygen levels!",
          responseTime: 5500,
          bodyPart: "cheast"
        }
      ];

      const getResponseTime = baseTime =>
        Math.max(baseTime - ((difficulty - 1) * 500), 3000);

      const getMaxConcurrentChallenges = () => {
        if (difficulty >= 4) return 3;
        if (difficulty >= 2) return 2;
        return 1;
      };

      const getInitialChallengeDelay = () => 2000;
      const getChallengeFrequency = () => {
        const base = 12000;
        return Math.max(base - (difficulty * 1000), 5000);
      };

      // Increase difficulty over score, show memory-mode popup at 5 points
      useEffect(() => {
        if (score >= 25) setDifficulty(6);
        else if (score >= 20) setDifficulty(5);
        else if (score >= 15) setDifficulty(4);
        else if (score >= 10) setDifficulty(3);
        else if (score >= 5) setDifficulty(2);
        else setDifficulty(1);

        if (score >= 5 && !memoryModePopupShown) {
          setShowMemoryModePopup(true);
          setMemoryModePopupShown(true);
        }
      }, [score]);

      // Flash warning only when <2s remaining
      useEffect(() => {
        if (showWarning && bodyRef.current) {
          let count = 0, flash = true;
          const maxFlashes = 4;
          const doFlash = () => {
            if (count >= maxFlashes) {
              setShowWarning(false);
              return;
            }
            bodyRef.current.style.backgroundColor = flash ? 'rgba(255,0,0,0.3)' : 'white';
            flash = !flash;
            count++;
            animationFrameRef.current = requestAnimationFrame(() =>
              setTimeout(doFlash, 300)
            );
          };
          doFlash();
          return () => cancelAnimationFrame(animationFrameRef.current);
        }
      }, [showWarning]);

      useEffect(() => {
        if (lifeLostNotification) {
          const t = setTimeout(() => setLifeLostNotification(false), 2500);
          return () => clearTimeout(t);
        }
      }, [lifeLostNotification]);

      // General message when no active challenges
      useEffect(() => {
        if (!gameActive) return;
        if (!currentStates.length) {
          setMessage(score > 0
            ? `READY FOR NEXT CHALLENGE! Score: ${score}`
            : `Monitor body systems and respond quickly!`);
        }
      }, [gameActive, currentStates, score]);

      // Main loop: spawn challenges
      useEffect(() => {
        if (!gameActive) return;
        if (livesLeft <= 0) { endGame(); return; }
        if (!challengeTimer && currentStates.length < getMaxConcurrentChallenges()) {
          const delay = currentStates.length === 0
            ? getInitialChallengeDelay()
            : getChallengeFrequency();
          setChallengeTimer(setTimeout(() => {
            addNewChallenge();
            setChallengeTimer(null);
          }, delay));
        }
        const backup = setTimeout(() => {
          if (currentStates.length < getMaxConcurrentChallenges() && gameActive && challengeTimer) {
            clearTimeout(challengeTimer);
            setChallengeTimer(null);
          }
        }, 8000);
        return () => {
          if (challengeTimer) clearTimeout(challengeTimer);
          clearTimeout(backup);
        };
      }, [gameActive, currentStates, livesLeft, challengeTimer, difficulty]);

      const addNewChallenge = () => {
        const available = states.filter(s => {
          if (currentStates.some(c => c.id === s.id)) return false;
          const type = s.id.split('_')[0];
          return !recentChallenges.includes(type);
        });
        if (!available.length) {
          setChallengeTimer(setTimeout(() => setChallengeTimer(null), 3000));
          return;
        }
        const newState = available[Math.floor(Math.random() * available.length)];
        setCurrentStates(prev => [...prev, newState]);
        setActiveSensors(prev => [...prev, newState.sensor]);
        setResponseNeeded(prev => ({...prev, [newState.id]: true}));
        setResponseCountdown(prev => ({...prev, [newState.id]: getResponseTime(newState.responseTime)}));

        // Countdown interval
        const ci = setInterval(() => {
          setResponseCountdown(prev => {
            const u = {...prev};
            if (u[newState.id]) {
              u[newState.id] -= 100;
              if (u[newState.id] <= 2000 && u[newState.id] > 0 && responseNeeded[newState.id]) {
                setShowWarning(true);
              }
            }
            return u;
          });
        }, 100);
        setCountdownIntervals(prev => ({...prev, [newState.id]: ci}));

        // Deadline
        setTimeout(() => {
          setResponseNeeded(prev => {
            const u = {...prev};
            if (u[newState.id]) {
              setLifeLostNotification(true);
              setLifeLostMessage(`LIFE LOST! ${newState.dangerMessage}`);
              setLivesLeft(l => l - 1);
              setTimeout(() => removeChallenge(newState.id), 2000);
              u[newState.id] = false;
            }
            return u;
          });
        }, getResponseTime(newState.responseTime));
      };

      const completeChallenge = id => {
        // award point, cooldown, etc.
        const parts = id.split('_');
        if (parts.length) {
          const type = parts[0];
          setRecentChallenges(prev => [...prev, type]);
          const cd = Math.max(15000 - (difficulty * 2000), 5000);
          setTimeout(() => setRecentChallenges(prev => prev.filter(x => x !== type)), cd);
        }
        setScore(s => s + 1);
        setMessage(`PERFECT! Score: ${score + 1}`);
        setCurrentStates(prev => prev.filter(s => s.id !== id));
        setTimeout(() => {
          removeChallenge(id);
          if (currentStates.length <= 1) setMessage(`PERFECT! Score: ${score + 1}`);
        }, 100);
        if (challengeTimer) clearTimeout(challengeTimer);
        const next = Math.max(4000 - (difficulty * 500), 1000);
        setChallengeTimer(setTimeout(() => setChallengeTimer(null), next));
      };

      const removeChallenge = id => {
        const st = currentStates.find(s => s.id === id);
        setCurrentStates(prev => prev.filter(s => s.id !== id));
        setTimeout(() => {
          if (st) setActiveSensors(prev => prev.filter(x => x !== st.sensor));
        }, 300);
        setActiveEffectors(prev => prev.filter(e => {
          const ss = states.find(s => s.id === id);
          return !ss || e !== ss.effector;
        }));
        if (effectorTimeouts[id]) clearTimeout(effectorTimeouts[id]);
        if (countdownIntervals[id]) clearInterval(countdownIntervals[id]);
        setHomeostasisRestored(prev => { const o = {...prev}; delete o[id]; return o; });
        setResponseNeeded(prev => { const o = {...prev}; delete o[id]; return o; });
        setResponseCountdown(prev => { const o = {...prev}; delete o[id]; return o; });
      };

      const findStateByEffector = eid => states.find(s => s.effector === eid) || null;

      const handleEffectorToggle = eid => {
        if (!gameActive) return;
        const rs = findStateByEffector(eid);
        if (!rs) return;
        const sid = rs.id;
        const isCurr = currentStates.some(s => s.id === sid);

        // Turning OFF
        if (activeEffectors.includes(eid)) {
          if (isCurr && homeostasisRestored[sid]) {
            setActiveEffectors(prev => prev.filter(x => x !== eid));
            completeChallenge(sid);
          } else {
            setActiveEffectors(prev => prev.filter(x => x !== eid));
            setMessage("Problem not fixed yet!");
            setLivesLeft(l => l - 1);
            setLifeLostNotification(true);
            setLifeLostMessage("LIFE LOST! You turned off too early!");
            setTimeout(() => { if (isCurr) removeChallenge(sid); }, 2000);
          }
          return;
        }

        // Correct initial activation
        if (isCurr && responseNeeded[sid]) {
          setActiveEffectors(prev => [...prev, eid]);
          setHomeostasisRestored(prev => ({...prev, [sid]: false}));
          setResponseNeeded(prev => ({...prev, [sid]: false}));
          const half = Math.floor(getResponseTime(rs.responseTime) / 2);
          const t1 = setTimeout(() => {
            setHomeostasisRestored(prev => ({...prev, [sid]: true}));
            const t2 = setTimeout(() => {
              if (activeEffectors.includes(eid)) {
                setMessage("You left it on too long!");
                setLivesLeft(l => l - 1);
                setLifeLostNotification(true);
                setLifeLostMessage("LIFE LOST! Overcompensation!");
                setTimeout(() => removeChallenge(sid), 2000);
              }
            }, 8000);
            setEffectorTimeouts(prev => ({...prev, [sid]: t2}));
          }, half);
          setEffectorTimeouts(prev => ({...prev, [sid + "_act"]: t1}));
        }
        // Wrong effector clicked
        else {
          setActiveEffectors(prev => [...prev, eid]);
          setMessage("Wrong effector! You lose a life!");
          setLivesLeft(l => l - 1);
          setLifeLostNotification(true);
          setLifeLostMessage("LIFE LOST! Wrong effector clicked!");
          const tw = setTimeout(() => {
            setActiveEffectors(prev => prev.filter(x => x !== eid));
          }, 1500);
          setEffectorTimeouts(prev => ({...prev, [eid + "_wrong"]: tw}));
        }
      };

      const startGame = () => {
        Object.values(effectorTimeouts).forEach(t => clearTimeout(t));
        Object.values(countdownIntervals).forEach(i => clearInterval(i));
        if (challengeTimer) clearTimeout(challengeTimer);
        setGameActive(true);
        setScore(0);
        setLivesLeft(3);
        setDifficulty(1);
        setMessage("Game started!");
        setCurrentStates([]);
        setActiveSensors([]);
        setActiveEffectors([]);
        setHomeostasisRestored({});
        setResponseNeeded({});
        setEffectorTimeouts({});
        setCountdownIntervals({});
        setResponseCountdown({});
        setChallengeTimer(null);
        setRecentChallenges([]);
        setMemoryModePopupShown(false);
      };
      const endGame = () => {
        Object.values(effectorTimeouts).forEach(t => clearTimeout(t));
        Object.values(countdownIntervals).forEach(i => clearInterval(i));
        if (challengeTimer) clearTimeout(challengeTimer);
        setGameActive(false);
        setMessage(`GAME OVER! Final score: ${score}.`);
        setCurrentStates([]);
        setActiveSensors([]);
        setActiveEffectors([]);
        setHomeostasisRestored({});
        setResponseNeeded({});
        setEffectorTimeouts({});
        setCountdownIntervals({});
        setChallengeTimer(null);
        setRecentChallenges([]);
      };

      const showHighlights = score < 5;

      return (
        <>
          {showMemoryModePopup && (
            <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-20">
              <div className="bg-white p-6 rounded-lg shadow-lg max-w-sm text-center">
                <h2 className="text-xl font-bold mb-4">New Mode!</h2>
                <p className="mb-4">
                  From now on, effectors will no longer highlight. You must remember the correct one!
                </p>
                <button
                  className="bg-blue-500 text-white px-4 py-2 rounded"
                  onClick={() => setShowMemoryModePopup(false)}
                >
                  Got it!
                </button>
              </div>
            </div>
          )}

          <div className="flex flex-col items-center justify-center min-h-screen p-4">
            <div className="text-center mb-4">
              <h1 className="text-3xl font-bold text-blue-700 mb-2">BODY BALANCE!</h1>
              <div className="mb-4">
                <button
                  onClick={startGame}
                  className="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg mr-4 text-xl"
                  disabled={gameActive}
                >
                  START GAME!
                </button>
                <button
                  onClick={endGame}
                  className="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg text-xl"
                  disabled={!gameActive}
                >
                  END GAME
                </button>
              </div>
              <div className="flex justify-center space-x-4 mb-2">
                <div className="text-xl font-semibold">
                  Score: <span className="text-green-600">{score}</span>
                </div>
                <div className="text-xl font-semibold">
                  Lives: <span className="text-red-600">{livesLeft}</span>
                </div>
                <div className="text-xl font-semibold">
                  Level: <span className="text-purple-600">{difficulty}</span>
                </div>
              </div>
              {lifeLostNotification && (
                <div className="bg-red-600 text-white p-3 mb-4 rounded-lg animate-pulse text-xl font-bold">
                  {lifeLostMessage}
                </div>
              )}
              <div
                className={`p-4 mb-4 text-center rounded-lg border-2 ${
                  showWarning
                    ? 'bg-red-100 border-red-500 animate-pulse'
                    : 'bg-yellow-100 border-yellow-500'
                }`}
              >
                {currentStates.length > 0 ? (
                  currentStates.map((st) => {
                    const isActive = activeEffectors.includes(st.effector);
                    const isRestored = homeostasisRestored[st.id];
                    const timeRem = responseCountdown[st.id] || 0;
                    const urgent = timeRem <= 2000 && timeRem > 0 && responseNeeded[st.id];
                    let msg = st.prompt;
                    if (isActive && !isRestored) msg = st.activeMessage;
                    else if (isActive && isRestored) msg = st.restoreMessage;
                    return (
                      <div key={st.id} className="mb-2">
                        <p
                          className={`text-xl font-bold ${
                            isRestored
                              ? 'text-green-600'
                              : isActive
                              ? 'text-blue-600'
                              : urgent
                              ? 'text-red-700'
                              : 'text-red-600'
                          }`}
                        >
                          {msg}
                          {timeRem > 0 && !isActive && !isRestored && (
                            <span
                              className={`ml-2 ${
                                urgent ? 'text-red-700 font-extrabold' : 'text-red-600'
                              }`}
                            >
                              {Math.ceil(timeRem / 1000)}s
                            </span>
                          )}
                        </p>
                      </div>
                    );
                  })
                ) : (
                  <p className="text-xl font-bold">{message}</p>
                )}
              </div>
            </div>

            <div className="flex w-full max-w-6xl justify-center">
              {/* Sensors */}
              <div className="w-1/4 pr-4">
                <h2 className="text-xl font-bold text-blue-600 mb-4 text-center">SENSORS</h2>
                <div className="space-y-4">
                  {Array.from(new Set(states.map((s) => s.sensor))).map((sensor) => {
                    const info = states.find((s) => s.sensor === sensor);
                    const active = activeSensors.includes(sensor);
                    return (
                      <div key={sensor} className="relative">
                        <div
                          className={`border-2 rounded-lg p-3 text-center transform transition-all duration-300 ${
                            active
                              ? 'bg-red-500 text-white border-red-700 font-bold scale-110 shadow-lg'
                              : 'bg-gray-100 border-gray-300'
                          }`}
                        >
                          {info.sensorName}
                        </div>
                        <div
                          className={`h-1 absolute top-1/2 right-0 w-16 transform translate-x-16 ${
                            active ? 'bg-red-500' : 'bg-gray-300'
                          }`}
                        ></div>
                      </div>
                    );
                  })}
                </div>
              </div>

              {/* Body */}
              <div
                ref={bodyRef}
                className="w-2/4 flex justify-center items-center border-2 border-gray-300 rounded-lg bg-white relative z-10"
                style={{ overflow: 'hidden' }}
              >
                <div
                  className="human-body"
                  style={{ width: '207px', position: 'relative', margin: '20px auto', height: '500px' }}
                >
                  {/* Insert all your SVG body parts here exactly as before */}
                </div>
                <div className="absolute top-4 left-4 right-4 bg-blue-600 text-white font-bold border border-blue-800 rounded p-2 text-center shadow-lg">
                  ⚠️ CONTROL CENTER: Brain &amp; Nervous System ⚠️
                </div>
                <div className="absolute bottom-4 left-4 right-4 bg-purple-100 border border-purple-300 rounded p-1 text-center text-sm">
                  <div className="font-bold">
                    Level {difficulty} {difficulty >= 3 ? '- Multiple challenges active!' : ''}
                  </div>
                  <div className="w-full bg-gray-200 rounded-full h-2 mt-1">
                    <div
                      className="h-2 rounded-full bg-purple-600"
                      style={{ width: `${Math.min((score / 25) * 100, 100)}%` }}
                    ></div>
                  </div>
                </div>
              </div>

              {/* Effectors */}
              <div className="w-1/4 pl-4">
                <h2 className="text-xl font-bold text-green-600 mb-4 text-center">EFFECTORS</h2>
                <div className="space-y-4">
                  {Array.from(new Set(states.map((s) => s.effector))).map((eff) => {
                    const info = states.find((s) => s.effector === eff);
                    const active = activeEffectors.includes(eff);
                    const needed =
                      showHighlights &&
                      currentStates.some((s) => s.effector === eff && responseNeeded[s.id]);
                    const canOff = currentStates.some((s) => s.effector === eff && homeostasisRestored[s.id]);
                    const btnText = active
                      ? canOff
                        ? info.restoreMessage.replace('!', '')
                        : info.effectorName
                      : info.effectorName;

                    return (
                      <div key={eff} className="relative">
                        <div
                          className={`h-1 absolute top-1/2 left-0 w-16 transform -translate-x-16 ${
                            activeSensors.includes(info.sensor) ? 'bg-red-500' : 'bg-gray-300'
                          }`}
                        ></div>
                        <button
                          onClick={() => handleEffectorToggle(eff)}
                          disabled={!gameActive}
                          className={`border-2 rounded-lg p-3 text-center w-full transform transition-all duration-300 ${
                            active
                              ? canOff
                                ? 'bg-red-500 text-white border-red-700 font-bold shadow-lg scale-110'
                                : 'bg-green-500 text-white border-green-700 font-bold shadow-lg scale-110'
                              : needed
                              ? 'bg-yellow-100 hover:bg-yellow-200 border-yellow-500 font-bold shadow'
                              : 'bg-gray-100 hover:bg-gray-200 border-gray-300'
                          }`}
                        >
                          {btnText}
                        </button>
                      </div>
                    );
                  })}
                </div>
              </div>
            </div>

            <div className="mt-8 p-4 bg-blue-50 border border-blue-200 rounded-lg max-w-3xl">
              <h2 className="text-xl font-bold text-blue-800 mb-2">HOW TO PLAY:</h2>
              <ol className="list-decimal pl-5 space-y-2">
                <li>Watch for EMERGENCY ALERTS! Your body is in trouble!</li>
                <li>When a sensor turns RED, find the matching response button.</li>
                <li>CLICK the correct effector to fix it.</li>
                <li>Turn OFF when told to avoid overcompensation.</li>
                <li>Score points for maintaining homeostasis.</li>
                <li>Challenges speed up and multiple can occur at once!</li>
                <li>After 5 points, effectors stop highlighting—you must remember!</li>
                <li>Game ends when you lose all 3 lives.</li>
              </ol>
            </div>
          </div>
        </>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<HomeostasisSimulator />);
  </script>
</body>
</html>
