<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Homeostasis Game</title>
  <!-- Tailwind CSS via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100">
  <div id="root"></div>

  <!-- Load React & ReactDOM as ES modules -->
  <script type="module">
    import React, { useState, useEffect, useRef } from 'https://cdn.skypack.dev/react';
    import { createRoot } from 'https://cdn.skypack.dev/react-dom/client';

    const HomeostasisSimulator = () => {
      // Game state
      const [gameActive, setGameActive] = useState(false);
      const [score, setScore] = useState(0);
      const [livesLeft, setLivesLeft] = useState(3);
      const [currentStates, setCurrentStates] = useState([]);
      const [activeSensors, setActiveSensors] = useState([]);
      const [activeEffectors, setActiveEffectors] = useState([]);
      const [homeostasisRestored, setHomeostasisRestored] = useState({});
      const [message, setMessage] = useState("Press Start to begin!");
      const [effectorTimeouts, setEffectorTimeouts] = useState({});
      const [responseNeeded, setResponseNeeded] = useState({});
      const [challengeTimer, setChallengeTimer] = useState(null);
      const [responseCountdown, setResponseCountdown] = useState({});
      const [countdownIntervals, setCountdownIntervals] = useState({});
      const [difficulty, setDifficulty] = useState(1);
      const [showWarning, setShowWarning] = useState(false);
      const [recentChallenges, setRecentChallenges] = useState([]);
      const [lifeLostNotification, setLifeLostNotification] = useState(false);
      const [lifeLostMessage, setLifeLostMessage] = useState("");
      
      // Refs for animation frames
      const animationFrameRef = useRef(null);
      const bodyRef = useRef(null);
      
      // Homeostasis states with their sensors and effectors
      const states = [
        { 
          id: "temperature_high", 
          prompt: "TOO HOT! Body temperature rising!", 
          sensor: "temperature_sensor",
          sensorName: "Temperature Sensor",
          effector: "sweat_glands",
          effectorName: "START SWEATING!",
          activeMessage: "Sweating... cooling down body...",
          restoreMessage: "Temperature normal! STOP SWEATING!",
          dangerMessage: "TOO HOT! You're overheating!",
          responseTime: 8000,
          bodyPart: "head"
        },
        { 
          id: "temperature_low", 
          prompt: "TOO COLD! Body temperature dropping!", 
          sensor: "temperature_sensor",
          sensorName: "Temperature Sensor",
          effector: "shiver_muscles",
          effectorName: "START SHIVERING!",
          activeMessage: "Shivering... warming up body...",
          restoreMessage: "Temperature normal! STOP SHIVERING!",
          dangerMessage: "TOO COLD! You're freezing!",
          responseTime: 8000,
          bodyPart: "hands"
        },
        { 
          id: "blood_sugar_high", 
          prompt: "SUGAR OVERLOAD! Glucose too high!", 
          sensor: "glucose_sensor",
          sensorName: "Glucose Sensor",
          effector: "insulin_release",
          effectorName: "RELEASE INSULIN!",
          activeMessage: "Insulin working... lowering blood sugar...",
          restoreMessage: "Sugar levels normal! STOP INSULIN!",
          dangerMessage: "SUGAR CRISIS! You need insulin now!",
          responseTime: 7000,
          bodyPart: "stomach"
        },
        { 
          id: "blood_sugar_low", 
          prompt: "SUGAR CRASH! Glucose too low!", 
          sensor: "glucose_sensor",
          sensorName: "Glucose Sensor",
          effector: "glucagon_release",
          effectorName: "RELEASE GLUCAGON!",
          activeMessage: "Glucagon working... raising blood sugar...",
          restoreMessage: "Sugar levels normal! STOP GLUCAGON!",
          dangerMessage: "ENERGY CRISIS! Blood sugar critical!",
          responseTime: 7000,
          bodyPart: "stomach"
        },
        { 
          id: "bladder_full", 
          prompt: "BLADDER FULL! Need to urinate!", 
          sensor: "bladder_sensor",
          sensorName: "Bladder Sensor",
          effector: "urination",
          effectorName: "CONTRACT BLADDER!",
          activeMessage: "Peeing! Emptying bladder...",
          restoreMessage: "Bladder emptied! STOP CONTRACTING!",
          dangerMessage: "EMERGENCY! Bladder about to burst!",
          responseTime: 6000,
          bodyPart: "legs"
        },
        { 
          id: "thirst", 
          prompt: "TOO THIRSTY! Water levels low!", 
          sensor: "thirst_sensor",
          sensorName: "Thirst Sensor",
          effector: "drink_water",
          effectorName: "DRINK WATER!",
          activeMessage: "Drinking... hydrating body...",
          restoreMessage: "Water levels normal! STOP DRINKING!",
          dangerMessage: "DEHYDRATION ALERT! Critical water shortage!",
          responseTime: 7000,
          bodyPart: "head"
        },
        { 
          id: "blood_pressure_high", 
          prompt: "PRESSURE SPIKE! BP too high!", 
          sensor: "pressure_sensor",
          sensorName: "Pressure Sensor",
          effector: "vasodilation",
          effectorName: "DILATE VESSELS!",
          activeMessage: "Vessels dilating... lowering pressure...",
          restoreMessage: "Pressure normal! RETURN TO NORMAL!",
          dangerMessage: "PRESSURE CRISIS! BP dangerously high!",
          responseTime: 6000,
          bodyPart: "cheast"
        },
        { 
          id: "oxygen_low", 
          prompt: "OXYGEN LOW! Can't breathe!", 
          sensor: "oxygen_sensor",
          sensorName: "Oxygen Sensor",
          effector: "increase_breathing",
          effectorName: "BREATHE FASTER!",
          activeMessage: "Breathing faster... increasing oxygen...",
          restoreMessage: "Oxygen normal! BREATHE NORMALLY!",
          dangerMessage: "SUFFOCATING! Critical oxygen levels!",
          responseTime: 5500,
          bodyPart: "cheast"
        }
      ];
      
      // Calculate response time based on score/difficulty
      const getResponseTime = (baseTime) => {
        return Math.max(baseTime - ((difficulty - 1) * 500), 3000); // Minimum 3 seconds
      };
      
      // Determine how many concurrent challenges based on difficulty
      const getMaxConcurrentChallenges = () => {
        if (difficulty >= 5) return 3;
        if (difficulty >= 3) return 2;
        return 1;
      };
      
      // Calculate initial challenge delay based on difficulty
      const getInitialChallengeDelay = () => {
        // Start more quickly
        return 2000; // Always start with a short 2-second delay
      };
      
      // Calculate challenge frequency based on difficulty
      const getChallengeFrequency = () => {
        // Slower challenges to prevent overwhelming students
        const baseFrequency = 12000; // 12 seconds base
        return Math.max(baseFrequency - (difficulty * 1000), 5000); // Minimum 5 seconds between challenges
      };
      
      // Effect to update difficulty based on score
      useEffect(() => {
        if (score >= 25) setDifficulty(6);
        else if (score >= 20) setDifficulty(5);
        else if (score >= 15) setDifficulty(4);
        else if (score >= 10) setDifficulty(3);
        else if (score >= 5) setDifficulty(2);
        else setDifficulty(1);
      }, [score]);
      
      // Flash warning animation - only for critical life-threatening situations
      useEffect(() => {
        if (showWarning && bodyRef.current) {
          let counter = 0;
          const maxFlashes = 4;
          let flash = true;
          
          const flashWarning = () => {
            if (counter >= maxFlashes) {
              setShowWarning(false);
              return;
            }
            
            if (bodyRef.current) {
              bodyRef.current.style.backgroundColor = flash ? 'rgba(255, 0, 0, 0.3)' : 'white';
            }
            
            flash = !flash;
            counter++;
            animationFrameRef.current = requestAnimationFrame(() => {
              setTimeout(flashWarning, 300);
            });
          };
          
          flashWarning();
          
          return () => {
            if (animationFrameRef.current) {
              cancelAnimationFrame(animationFrameRef.current);
            }
          };
        }
      }, [showWarning]);
      
      // Life lost notification effect
      useEffect(() => {
        if (lifeLostNotification) {
          // Clear the notification after 2.5 seconds
          const timeout = setTimeout(() => {
            setLifeLostNotification(false);
          }, 2500);
          
          return () => clearTimeout(timeout);
        }
      }, [lifeLostNotification]);
      
      // Reset state after completing a challenge
      const completeChallenge = (stateId) => {
        try {
          // Add this challenge type to recently completed list to prevent repeat
          const stateParts = stateId.split('_');
          if (stateParts.length > 0) {
            const challengeType = stateParts[0]; // Extract challenge type (e.g., "temperature" from "temperature_high")
            setRecentChallenges(prev => [...prev, challengeType]);
            
            // Remove from recent challenges after a cooldown period (shorter at higher difficulty)
            const cooldownTime = Math.max(15000 - (difficulty * 2000), 5000); // Reduces from 15s to 5s
            setTimeout(() => {
              setRecentChallenges(prev => prev.filter(c => c !== challengeType));
            }, cooldownTime);
          }
          
          setScore(score => score + 1);
          
          // Show success message
          setMessage(`PERFECT! Homeostasis maintained. Score: ${score + 1}`);
          
          // Immediately clear the challenge from the display to prevent message overlap
          setCurrentStates(prev => prev.filter(state => state && state.id !== stateId));
          
          // Then after a short delay, clean up all other state
          setTimeout(() => {
            removeChallenge(stateId);
            
            // Ensure message is still showing success if no other challenges are active
            if (currentStates.length <= 1) { // Only the one we're removing
              setMessage(`PERFECT! Homeostasis maintained. Score: ${score + 1}`);
            }
          }, 100);
          
          // Also add a cooldown period before new challenges can appear - shorter at higher difficulties
          if (challengeTimer) {
            clearTimeout(challengeTimer);
          }
          
          // Reduce the cooldown as difficulty increases
          const nextChallengeDelay = Math.max(4000 - (difficulty * 500), 1000); // From 4s to 1s
          setChallengeTimer(setTimeout(() => {
            setChallengeTimer(null);
          }, nextChallengeDelay));
        } catch (error) {
          console.error("Error in completeChallenge:", error);
        }
      };
      
      // Effect to update messages based on challenge states
      useEffect(() => {
        if (!gameActive) return;
        
        // Handle general messages only when no specific challenge messages are active
        if (currentStates.length === 0) {
          if (score > 0) {
            setMessage(`READY FOR NEXT CHALLENGE! Score: ${score}`);
          } else {
            setMessage(`Monitor body systems and respond quickly!`);
          }
        }
      }, [gameActive, currentStates, score]);
      
      // Game logic
      useEffect(() => {
        if (!gameActive) return;
        
        if (livesLeft <= 0) {
          endGame();
          return;
        }
        
        // Debug log to track when new challenges should be created
        if (!challengeTimer && currentStates.length < getMaxConcurrentChallenges()) {
          console.log("Should create new challenge. Current challenges:", currentStates.length, "Max:", getMaxConcurrentChallenges());
          
          // Challenges come faster to make game more exciting
          const challengeDelay = currentStates.length === 0 ? 
            getInitialChallengeDelay() : // First challenge comes quickly
            getChallengeFrequency(); // Subsequent challenges based on difficulty
          
          console.log("Setting challenge delay:", challengeDelay, "ms");
          
          const timer = setTimeout(() => {
            console.log("Timer fired, creating new challenge");
            addNewChallenge();
            setChallengeTimer(null);
          }, challengeDelay);
          
          setChallengeTimer(timer);
        }
        
        // Periodically check if we should add more challenges (backup timer)
        const backupTimer = setTimeout(() => {
          if (currentStates.length < getMaxConcurrentChallenges() && gameActive) {
            console.log("Backup timer fired - ensuring new challenge is created");
            if (challengeTimer) {
              clearTimeout(challengeTimer);
              setChallengeTimer(null);
            }
          }
        }, 8000);
        
        return () => {
          if (challengeTimer) {
            clearTimeout(challengeTimer);
          }
          clearTimeout(backupTimer);
        };
      }, [gameActive, currentStates, livesLeft, challengeTimer, difficulty]);
      
      // Add a new challenge
      const addNewChallenge = () => {
        try {
          if (!gameActive) return;
          
          // Get states not currently active
          const availableStates = states.filter(state => {
            if (!state || typeof state !== 'object' || !state.id) {
              return false;
            }
            
            // Filter out states that are currently active
            if (currentStates.some(current => current && current.id === state.id)) {
              return false;
            }
            
            // Filter out state types that were recently completed (prevent immediate repeats)
            const stateParts = state.id.split('_');
            if (stateParts.length === 0) return false;
            
            const stateType = stateParts[0]; // e.g., "temperature" from "temperature_high"
            return !recentChallenges.includes(stateType);
          });
          
          if (availableStates.length === 0) {
            // If all challenge types are on cooldown, just wait
            setChallengeTimer(setTimeout(() => {
              setChallengeTimer(null);
            }, 3000));
            return;
          }
          
          const randomIndex = Math.floor(Math.random() * availableStates.length);
          const newState = availableStates[randomIndex];
          
          if (!newState || !newState.id) {
            console.error("Invalid state selected:", newState);
            return;
          }
          
          setCurrentStates(prev => [...prev, newState]);
          setActiveSensors(prev => [...prev, newState.sensor]);
          setResponseNeeded(prev => ({...prev, [newState.id]: true}));
          setResponseCountdown(prev => ({...prev, [newState.id]: getResponseTime(newState.responseTime)}));
          
          // Start countdown for this challenge
          const countdownInterval = setInterval(() => {
            setResponseCountdown(prev => {
              const updatedCountdown = {...prev};
              if (updatedCountdown[newState.id]) {
                updatedCountdown[newState.id] -= 100;
                
                // Only show critical warning when about to lose a life (last 2 seconds)
                if (updatedCountdown[newState.id] <= 2000 && updatedCountdown[newState.id] > 0 && responseNeeded[newState.id]) {
                  setShowWarning(true);
                }
              }
              return updatedCountdown;
            });
          }, 100);
          
          setCountdownIntervals(prev => ({...prev, [newState.id]: countdownInterval}));
          
          // Set timeout for response deadline
          setTimeout(() => {
            setResponseNeeded(prev => {
              const updated = {...prev};
              if (updated[newState.id]) {
                // Show life lost notification
                setLifeLostNotification(true);
                setLifeLostMessage(`LIFE LOST! ${newState.dangerMessage || "Challenge failed!"}`);
                
                setLivesLeft(lives => lives - 1);
                setShowWarning(true); // Flash warning when losing a life
                
                // Clear this state after a penalty
                setTimeout(() => {
                  removeChallenge(newState.id);
                  setShowWarning(false);
                }, 2000);
                
                updated[newState.id] = false;
              }
              return updated;
            });
          }, getResponseTime(newState.responseTime));
        } catch (error) {
          console.error("Error in addNewChallenge:", error);
        }
      };
      
      // Remove a challenge
      const removeChallenge = (stateId) => {
        try {
          if (!stateId) return;
          
          // Preserve the state for a moment to allow proper UI feedback before removing
          const stateToRemove = currentStates.find(state => state && state.id === stateId);
          
          setCurrentStates(prev => prev.filter(state => state && state.id !== stateId));
          
          // Delay the sensor deactivation slightly to prevent UI confusion
          setTimeout(() => {
            setActiveSensors(prev => {
              if (!stateToRemove) return prev;
              return prev.filter(sensor => sensor !== stateToRemove.sensor);
            });
          }, 300);
          
          setActiveEffectors(prev => {
            const stateToRemove = states.find(s => s && s.id === stateId);
            return prev.filter(effector => !stateToRemove || effector !== stateToRemove.effector);
          });
          
          // Clear any timers for this challenge
          if (effectorTimeouts[stateId]) {
            clearTimeout(effectorTimeouts[stateId]);
            setEffectorTimeouts(prev => {
              const updated = {...prev};
              delete updated[stateId];
              return updated;
            });
          }
          
          if (countdownIntervals[stateId]) {
            clearInterval(countdownIntervals[stateId]);
            setCountdownIntervals(prev => {
              const updated = {...prev};
              delete updated[stateId];
              return updated;
            });
          }
          
          setHomeostasisRestored(prev => {
            const updated = {...prev};
            delete updated[stateId];
            return updated;
          });
          
          setResponseNeeded(prev => {
            const updated = {...prev};
            delete updated[stateId];
            return updated;
          });
          
          setResponseCountdown(prev => {
            const updated = {...prev};
            delete updated[stateId];
            return updated;
          });
        } catch (error) {
          console.error("Error in removeChallenge:", error);
        }
      };
      
      // Find state by effector
      const findStateByEffector = (effectorId) => {
        if (!effectorId) return null;
        return states.find(state => state && state.effector === effectorId) || null;
      };
      
      // Handle effector activation
      const handleEffectorToggle = (effectorId) => {
        try {
          if (!gameActive || !effectorId) return;
          
          const relatedState = findStateByEffector(effectorId);
          if (!relatedState || !relatedState.id) return;
          
          const stateId = relatedState.id;
          const isCurrentChallenge = currentStates.some(state => state && state.id === stateId);
          
          // If already active, turn it off
          if (activeEffectors.includes(effectorId)) {
            // Check if it should be turned off (homeostasis restored)
            if (isCurrentChallenge && homeostasisRestored[stateId]) {
              // Correct action - turn off when homeostasis is restored
              setActiveEffectors(prev => prev.filter(e => e !== effectorId));
              
              if (effectorTimeouts[stateId]) {
                clearTimeout(effectorTimeouts[stateId]);
              }
              
              // Use the complete challenge function
              completeChallenge(stateId);
            } else {
              // Turned off too early
              setActiveEffectors(prev => prev.filter(e => e !== effectorId));
              setMessage("Problem not fixed yet!");
              setLivesLeft(lives => lives - 1);
              
              // Show life lost notification
              setLifeLostNotification(true);
              setLifeLostMessage("LIFE LOST! You turned off the response too soon!");
              
              setTimeout(() => {
                if (isCurrentChallenge) {
                  removeChallenge(stateId);
                }
              }, 2000);
            }
            return;
          }
          
          // Handle initial activation
          if (isCurrentChallenge && responseNeeded[stateId]) {
            // Correct response - activate effector
            setActiveEffectors(prev => [...prev, effectorId]);
            setHomeostasisRestored(prev => ({...prev, [stateId]: false}));
            setResponseNeeded(prev => ({...prev, [stateId]: false}));
            
            // After some time, signal that homeostasis is being restored
            const responseTime = Math.floor(getResponseTime(relatedState.responseTime) / 2);
            
            const timeout = setTimeout(() => {
              setHomeostasisRestored(prev => ({...prev, [stateId]: true}));
              
              // Need to turn it off in time - but give MUCH more time (8 seconds)
              const turnOffTimeout = setTimeout(() => {
                if (activeEffectors.includes(effectorId)) {
                  setMessage("You need to turn off the response!");
                  setLivesLeft(lives => lives - 1);
                  
                  // Show life lost notification
                  setLifeLostNotification(true);
                  setLifeLostMessage("LIFE LOST! Overcompensation! Response left on too long!");
                  
                  setTimeout(() => {
                    removeChallenge(stateId);
                  }, 2000);
                }
              }, 8000); // Much longer time to turn it off (8 seconds)
              
              setEffectorTimeouts(prev => ({...prev, [stateId]: turnOffTimeout}));
              
            }, responseTime);
            
            setEffectorTimeouts(prev => ({...prev, [stateId + "_activate"]: timeout}));
            
          } else if (!isCurrentChallenge) {
            // Activating an effector with no challenge
            setActiveEffectors(prev => [...prev, effectorId]);
            setMessage("No problem detected! Don't overcompensate!");
            
            // Auto turn off after a short time
            const wrongEffectorTimeout = setTimeout(() => {
              setActiveEffectors(prev => prev.filter(e => e !== effectorId));
            }, 1500);
            
            setEffectorTimeouts(prev => ({...prev, [effectorId + "_wrong"]: wrongEffectorTimeout}));
          }
        } catch (error) {
          console.error("Error in handleEffectorToggle:", error);
        }
      };
      
      const startGame = () => {
        try {
          // Clear any existing timers first
          Object.values(effectorTimeouts).forEach(timeout => {
            if (timeout) clearTimeout(timeout);
          });
          Object.values(countdownIntervals).forEach(interval => {
            if (interval) clearInterval(interval);
          });
          if (challengeTimer) clearTimeout(challengeTimer);
          
          // Reset game state
          setGameActive(true);
          setScore(0);
          setLivesLeft(3);
          setDifficulty(1);
          setMessage("Game started! Monitor body systems!");
          setCurrentStates([]);
          setActiveSensors([]);
          setActiveEffectors([]);
          setHomeostasisRestored({});
          setResponseNeeded({});
          setEffectorTimeouts({});
          setCountdownIntervals({});
          setResponseCountdown({});
          setChallengeTimer(null);
          setRecentChallenges([]);
        } catch (error) {
          console.error("Error in startGame:", error);
        }
      };
      
      const endGame = () => {
        try {
          // Clear all timers
          Object.values(effectorTimeouts).forEach(timeout => {
            if (timeout) clearTimeout(timeout);
          });
          Object.values(countdownIntervals).forEach(interval => {
            if (interval) clearInterval(interval);
          });
          if (challengeTimer) clearTimeout(challengeTimer);
          
          setGameActive(false);
          setMessage(`GAME OVER! Final score: ${score}. Press Start to play again!`);
          
          // Clear all states
          setCurrentStates([]);
          setActiveSensors([]);
          setActiveEffectors([]);
          setHomeostasisRestored({});
          setResponseNeeded({});
          setEffectorTimeouts({});
          setCountdownIntervals({});
          setChallengeTimer(null);
          setRecentChallenges([]);
        } catch (error) {
          console.error("Error in endGame:", error);
        }
      };

      return (
        <div className="flex flex-col items-center justify-center min-h-screen p-4">
          <div className="text-center mb-4">
            <h1 className="text-3xl font-bold text-blue-700 mb-2">BODY BALANCE!</h1>
            <p className="text-md text-gray-700 mb-4">Keep your body in homeostasis or FACE THE CONSEQUENCES!</p>
            
            <div className="mb-4">
              <button 
                onClick={startGame} 
                className="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg mr-4 text-xl"
                disabled={gameActive}
              >
                START GAME!
              </button>
              
              <button 
                onClick={endGame} 
                className="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg text-xl"
                disabled={!gameActive}
              >
                END GAME
              </button>
            </div>
            
            <div className="flex justify-center space-x-4 mb-2">
              <div className="text-xl font-semibold">Score: <span className="text-green-600">{score}</span></div>
              <div className="text-xl font-semibold">Lives: <span className="text-red-600">{livesLeft}</span></div>
              <div className="text-xl font-semibold">Level: <span className="text-purple-600">{difficulty}</span></div>
            </div>
            
            {lifeLostNotification && (
              <div className="bg-red-600 text-white p-3 mb-4 rounded-lg animate-pulse text-xl font-bold">
                {lifeLostMessage}
              </div>
            )}
            
            <div className={`p-4 mb-4 text-center rounded-lg border-2 ${
              showWarning ? 'bg-red-100 border-red-500 animate-pulse' : 
              'bg-yellow-100 border-yellow-500'
            }`}>
              {currentStates.length > 0 ? (
                currentStates.map(state => {
                  if (!state || !state.id) return null;
                  
                  const isActive = activeEffectors.includes(state.effector);
                  const isRestored = homeostasisRestored[state.id];
                  const timeRemaining = responseCountdown[state.id] || 0;
                  const isUrgent = timeRemaining <= 2000 && timeRemaining > 0 && responseNeeded[state.id];
                  
                  let statusMessage = state.prompt || "Challenge active";
                  if (isActive && !isRestored) {
                    statusMessage = state.activeMessage || "Response active...";
                  } else if (isActive && isRestored) {
                    statusMessage = state.restoreMessage || "Homeostasis restored!";
                  }
                  
                  return (
                    <div key={state.id} className="mb-2">
                      <p className={`text-xl font-bold ${
                        isRestored ? 'text-green-600' : 
                        isActive ? 'text-blue-600' : 
                        isUrgent ? 'text-red-700' : 'text-red-600'
                      }`}>
                        {statusMessage}
                        {timeRemaining > 0 && !isActive && !isRestored && (
                          <span className={`ml-2 ${isUrgent ? 'text-red-700 font-extrabold' : 'text-red-600'}`}>
                            {Math.ceil(timeRemaining / 1000)}s
                          </span>
                        )}
                      </p>
                    </div>
                  );
                })
              ) : (
                <p className="text-xl font-bold">{message}</p>
              )}
            </div>
          </div>
          
          <div className="flex w-full max-w-6xl justify-center">
            <div className="w-1/4 pr-4">
              <h2 className="text-xl font-bold text-blue-600 mb-4 text-center">SENSORS</h2>
              <div className="space-y-4">
                {Array.from(new Set(states.filter(s => s).map(state => state.sensor)))
                  .filter(sensor => sensor)
                  .map(sensor => {
                    const sensorState = states.find(s => s && s.sensor === sensor);
                    const sensorName = sensorState?.sensorName || "Sensor";
                    const isActive = activeSensors.includes(sensor);
                    return (
                      <div key={sensor} className="relative">
                        <div 
                          className={`border-2 rounded-lg p-3 text-center transition-all duration-300 transform ${
                            isActive ? 'bg-red-500 text-white border-red-700 font-bold scale-110 shadow-lg' : 
                            'bg-gray-100 border-gray-300'
                          }`}
                        >
                          {sensorName}
                        </div>
                        <div 
                          className={`h-1 absolute top-1/2 right-0 w-16 transform translate-x-16 ${
                            isActive ? 'bg-red-500' : 'bg-gray-300'
                          }`}
                        ></div>
                      </div>
                    );
                  })}
              </div>
            </div>
            
            <div 
              ref={bodyRef} 
              className="w-2/4 flex justify-center items-center border-2 border-gray-300 rounded-lg bg-white relative"
              style={{ overflow: 'hidden' }}
            >
              <div className="human-body" style={{ width: '207px', position: 'relative', margin: '20px auto', height: '500px' }}>
                <!-- SVG body parts here (all your SVGs as originally provided) -->
              </div>
              
              <div className="absolute top-4 left-4 right-4 bg-blue-600 text-white font-bold border border-blue-800 rounded p-2 text-center shadow-lg">
                ⚠️ CONTROL CENTER: Brain & Nervous System ⚠️
              </div>
              
              <div className="absolute bottom-4 left-4 right-4 bg-purple-100 border border-purple-300 rounded p-1 text-center text-sm">
                <div className="font-bold">Level {difficulty} {difficulty >= 3 ? '- Multiple challenges active!' : ''}</div>
                <div className="w-full bg-gray-200 rounded-full h-2 mt-1">
                  <div className="bg-purple-600 h-2 rounded-full" style={{ width: `${Math.min(score/25 * 100, 100)}%` }}></div>
                </div>
              </div>
            </div>
            
            <div className="w-1/4 pl-4">
              <h2 className="text-xl font-bold text-green-600 mb-4 text-center">EFFECTORS</h2>
              <div className="space-y-4">
                {Array.from(new Set(states.filter(s => s).map(state => state.effector)))
                  .filter(effector => effector)
                  .map(effector => {
                    const effectorState = states.find(s => s && s.effector === effector);
                    const effectorName = effectorState?.effectorName || "Effector";
                    const isActive = activeEffectors.includes(effector);
                    const relatedState = findStateByEffector(effector);
                    const isNeeded = currentStates.some(state => state && state.effector === effector && responseNeeded[state.id]);
                    const shouldTurnOff = currentStates.some(state => state && state.effector === effector && homeostasisRestored[state.id]);
                    
                    const buttonText = isActive ? 
                      (shouldTurnOff ? (relatedState?.restoreMessage || "STOP!").replace("!", "") : effectorName) :
                      effectorName;
                    
                    return (
                      <div key={effector} className="relative">
                        <div className={`h-1 absolute top-1/2 left-0 w-16 transform -translate-x-16 ${
                          activeSensors.includes(relatedState?.sensor) ? 'bg-red-500' : 'bg-gray-300'
                        }`}></div>
                        <button 
                          onClick={() => handleEffectorToggle(effector)}
                          disabled={!gameActive}
                          className={`border-2 rounded-lg p-3 text-center w-full transition-all duration-300 transform ${
                            isActive 
                              ? (shouldTurnOff 
                                 ? 'bg-red-500 text-white border-red-700 font-bold shadow-lg scale-110' 
                                 : 'bg-green-500 text-white border-green-700 font-bold shadow-lg scale-110'
                                ) 
                              : isNeeded
                                ? 'bg-yellow-100 hover:bg-yellow-200 border-yellow-500 font-bold shadow'
                                : 'bg-gray-100 hover:bg-gray-200 border-gray-300'
                          }`}
                        >
                          {buttonText}
                        </button>
                      </div>
                    );
                  })}
              </div>
            </div>
          </div>
          
          <div className="mt-8 p-4 bg-blue-50 border border-blue-200 rounded-lg max-w-3xl">
            <h2 className="text-xl font-bold text-blue-800 mb-2">HOW TO PLAY:</h2>
            <ol className="list-decimal pl-5 space-y-2">
              <li>Watch for EMERGENCY ALERTS! Your body is in trouble!</li>
              <li>When a sensor turns RED, quickly find the matching response button.</li>
              <li>CLICK the correct effector button to start fixing the problem.</li>
              <li>Watch for the message telling you to STOP the response.</li>
              <li>You MUST turn OFF the effector when told to avoid overcompensation.</li>
              <li>Score points for successfully maintaining homeostasis.</li>
              <li>As you level up, challenges come faster and multiple problems can happen at once!</li>
              <li>Game ends when you lose all 3 lives. HOW LONG CAN YOU SURVIVE?</li>
            </ol>
            <div className="mt-4 p-2 bg-yellow-50 border border-yellow-200 rounded">
              <strong>Remember:</strong> Homeostasis works through negative feedback loops:
              <div className="flex justify-between items-center mt-2 text-sm">
                <div className="text-center px-2">
                  <div className="w-16 h-16 mx-auto rounded-full bg-red-200 border-2 border-red-500 flex items-center justify-center">
                    <span className="font-bold">SENSORS</span>
                  </div>
                  <div>Detect Change</div>
                </div>
                <div className="text-3xl">→</div>
                <div className="text-center px-2">
                  <div className="w-16 h-16 mx-auto rounded-full bg-blue-200 border-2 border-blue-500 flex items-center justify-center">
                    <span className="font-bold">BRAIN</span>
                  </div>
                  <div>Processes Info</div>
                </div>
                <div className="text-3xl">→</div>
                <div className="text-center px-2">
                  <div className="w-16 h-16 mx-auto rounded-full bg-green-200 border-2 border-green-500 flex items-center justify-center">
                    <span className="font-bold">EFFECTORS</span>
                  </div>
                  <div>Take Action</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    // Mount into #root
    const container = document.getElementById('root');
    const root = createRoot(container);
    root.render(<HomeostasisSimulator />);
  </script>
</body>
</html>
